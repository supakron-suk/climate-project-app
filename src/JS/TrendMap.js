// Trendmap.js
export const TrendMap = (dataByYear, startYear, endYear, region, province, valueKey) => {
  if (startYear > endYear) {
    console.error("Start year must be less than or equal to end year.");
    return null;
  }

  const numberOfYears = endYear - startYear;
  console.log(`üîç TrendMap: Years requested = ${numberOfYears} years (${startYear} to ${endYear})`);
  // ‡∏ü‡∏Å‡∏£‡∏≠‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏≤‡∏°‡∏†‡∏π‡∏°‡∏¥‡∏†‡∏≤‡∏Ñ
  const filterByRegion = (features, region) => {
    if (region === 'Thailand') return features; 
    return features.filter((feature) => feature.properties.region === region);
  };

  // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏£‡∏≠‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏≤‡∏°‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏±‡∏î
  const filterByProvince = (features, province) => {
    if (!province) return features; // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏£‡∏∞‡∏ö‡∏∏‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏±‡∏î ‡πÉ‡∏´‡πâ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡∏ó‡∏∏‡∏Å‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏±‡∏î
    return features.filter((feature) => feature.properties.name === province);
  };

  const trends = []; // ‡πÉ‡∏ä‡πâ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå
  const geometryMap = {}; // ‡πÉ‡∏ä‡πâ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏≤‡∏á‡∏†‡∏π‡∏°‡∏¥‡∏®‡∏≤‡∏™‡∏ï‡∏£‡πå (geometry)

  // ‡∏ß‡∏ô‡∏•‡∏π‡∏õ‡∏õ‡∏µ‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î
  for (let year = startYear; year <= endYear; year++) {
    const geojson = dataByYear[year]; // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• GeoJSON ‡∏ï‡∏≤‡∏°‡∏õ‡∏µ
    if (!geojson) continue; // ‡∏Ç‡πâ‡∏≤‡∏°‡∏õ‡∏µ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•

    // ‡∏Å‡∏£‡∏≠‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏≤‡∏°‡∏†‡∏π‡∏°‡∏¥‡∏†‡∏≤‡∏Ñ‡πÅ‡∏•‡∏∞‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏±‡∏î
    let filteredFeatures = filterByRegion(geojson.features, region);
    filteredFeatures = filterByProvince(filteredFeatures, province);

    // ‡∏ß‡∏ô‡∏•‡∏π‡∏õ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏Å‡∏£‡∏≠‡∏á‡πÅ‡∏•‡πâ‡∏ß
    filteredFeatures.forEach((feature) => {
      const { [valueKey]: value, month, name, region: featureRegion } = feature.properties;

      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• value ‡πÅ‡∏•‡∏∞‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏°‡∏µ‡∏Ñ‡πà‡∏≤‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
      if (typeof value === 'number' && month >= 1 && month <= 12) {
        trends.push({ year, name, value, month, region: featureRegion });
        // ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏≤‡∏á‡∏†‡∏π‡∏°‡∏¥‡∏®‡∏≤‡∏™‡∏ï‡∏£‡πå‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà
        if (!geometryMap[name]) geometryMap[name] = feature.geometry;
      }
    });
  }

  // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡πÅ‡∏•‡∏∞‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤ null
  if (trends.length === 0) {
    console.warn("No trends data available.");
    return null;
  }

  // ‡∏à‡∏±‡∏î‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå‡∏ï‡∏≤‡∏°‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà (name)
  const groupedTrends = trends.reduce((acc, curr) => {
    const key = curr.name; // ‡πÉ‡∏ä‡πâ‡∏ä‡∏∑‡πà‡∏≠‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡∏µ‡∏¢‡πå
    if (!acc[key]) acc[key] = [];
    acc[key].push({ year: curr.year, value: curr.value, month: curr.month }); // ‡πÄ‡∏Å‡πá‡∏ö‡∏õ‡∏µ, value, ‡πÅ‡∏•‡∏∞‡πÄ‡∏î‡∏∑‡∏≠‡∏ô
    return acc;
  }, {});

  // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡πà‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢‡∏Ç‡∏≠‡∏á value ‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏õ‡∏µ
  const yearlyTrends = Object.entries(groupedTrends).map(([area, data]) => {
    const yearlyData = {};
    
    // ‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• value ‡∏£‡∏≤‡∏¢‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏£‡∏≤‡∏¢‡∏õ‡∏µ
    data.forEach(({ year, value }) => {
      if (!yearlyData[year]) {
        yearlyData[year] = { sum: 0, count: 0 };
      }
      yearlyData[year].sum += value;
      yearlyData[year].count += 1;
    });

    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡πà‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏õ‡∏µ
    const yearlyAverages = Object.entries(yearlyData).map(([year, { sum, count }]) => {
      return { year: parseInt(year), value: sum / count };
    });

    return { area, yearlyAverages };
  });

  // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡πà‡∏≤ slope ‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà ‡πÅ‡∏•‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• GeoJSON
  const features = yearlyTrends.map(({ area, yearlyAverages }) => {
    const slope = calculateModifiedTheilSenSlope(yearlyAverages, 'value'); // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì slope ‡∏à‡∏≤‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô‡∏£‡∏≤‡∏¢‡∏õ‡∏µ
    const roundedSlope = parseFloat(slope.toFixed(2)); // ‡∏õ‡∏±‡∏î‡∏Ñ‡πà‡∏≤ slope ‡πÉ‡∏´‡πâ‡∏°‡∏µ‡∏ó‡∏®‡∏ô‡∏¥‡∏¢‡∏° 2 ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á
    return {
      type: "Feature", // ‡∏£‡∏∞‡∏ö‡∏∏‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• GeoJSON
      geometry: geometryMap[area], // ‡∏ô‡∏≥‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏≤‡∏á‡∏†‡∏π‡∏°‡∏¥‡∏®‡∏≤‡∏™‡∏ï‡∏£‡πå‡∏°‡∏≤‡πÉ‡∏™‡πà
      properties: {
        name: area, // ‡∏ä‡∏∑‡πà‡∏≠‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà
        slope_value: roundedSlope, // ‡∏Ñ‡πà‡∏≤ slope
        region: trends.find((t) => t.name === area).region, // ‡∏£‡∏∞‡∏ö‡∏∏‡∏†‡∏π‡∏°‡∏¥‡∏†‡∏≤‡∏Ñ
      },
    };
  });

  // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• GeoJSON ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå
  const geojson_Trendmap = {
    type: "FeatureCollection", // ‡∏£‡∏∞‡∏ö‡∏∏‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏õ‡πá‡∏ô FeatureCollection
    features, // ‡πÉ‡∏™‡πà‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Feature ‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ß‡πâ
  };

  return {
    geojson: geojson_Trendmap,
    numberOfYears: numberOfYears
  };
  
};

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Modified Theil-Sen Slope
const calculateModifiedTheilSenSlope = (data, valueKey) => {
  const n = data.length; // ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
  const slopes = []; // ‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡∏±‡∏ô (slope)

  // ‡∏ß‡∏ô‡∏•‡∏π‡∏õ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏ö‡∏ö‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡∏™‡∏≠‡∏á‡∏à‡∏∏‡∏î
  for (let i = 0; i < n - 1; i++) {
    for (let j = i + 1; j < n; j++) {
      const { year: x1, [valueKey]: y1 } = data[i];
      const { year: x2, [valueKey]: y2 } = data[j];
      const slope = (y2 - y1) / (x2 - x1); // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡∏±‡∏ô‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏à‡∏∏‡∏î‡∏™‡∏≠‡∏á‡∏à‡∏∏‡∏î
      slopes.push(slope); // ‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡∏±‡∏ô‡πÉ‡∏ô‡∏≠‡∏≤‡πÄ‡∏£‡∏¢‡πå
    }
  }

  // ‡∏à‡∏±‡∏î‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡∏±‡∏ô‡∏à‡∏≤‡∏Å‡∏ô‡πâ‡∏≠‡∏¢‡πÑ‡∏õ‡∏°‡∏≤‡∏Å
  slopes.sort((a, b) => a - b);

  // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡πà‡∏≤ median ‡∏Ç‡∏≠‡∏á‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡∏±‡∏ô
  const mid = Math.floor(slopes.length / 2);
  return slopes.length % 2 === 0 ? (slopes[mid - 1] + slopes[mid]) / 2 : slopes[mid];
};

